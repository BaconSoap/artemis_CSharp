<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Artemis Entity System Framework</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
          <h1>Artemis</h1>
          <p>An Entity System Framework</p>
          <p class="view"><a href="https://github.com/thelinuxlich/artemis_CSharp">View the Project on GitHub <small>thelinuxlich/artemis_CSharp</small></a></p>
          <ul>
              <li><a href="https://github.com/thelinuxlich/artemis_CSharp/zipball/master">Download <strong>ZIP File</strong></a></li>
              <li><a href="https://github.com/thelinuxlich/artemis_CSharp/tarball/master">Download <strong>TAR Ball</strong></a></li>
              <li><a href="https://github.com/thelinuxlich/artemis_CSharp">View On <strong>GitHub</strong></a></li>
          </ul>
      </header>
      <section>
          <h3>Description</h3>
          Artemis is a high performance Entity System framework for games, <a href="http://gamadu.com/artemis">originally written in Java</a> by Arni Arent and Tiago Costa, now ported to C#. <br/>
          Its goal is to provide a clean API to abstract your game world organization into entities, components and systems.<br/>
          Artemis has no dependencies (for PC, in Xbox and Windows Phone 7 we have one) and can be used with any game framework or library, 2D or 3D, and even multiplatform, if you use it with Mono/MonoTouch/Mono4Android.
     </section>
     <section>
          <h3>Differences from the original version</h3>
          We support all the features included in the original Java version, but we've also added the following features:
          <ul>  
              <li>Multithreading Support (two ways of doing this)</li>
              <li>Specialized System templates for your multithreading needs</li>
              <li>Communication between Systems using a Blackboard approach</li>
              <li>Bugs fixed, performance improvements</li>
              <li>Xbox/WP7/Mono(Android/Linux/Mac/iOS) support </li>
              <li>Events for intercepting adding/removal of entities/components</li>
              <li>Entity Pool (to make objects reusable, minimize garbage collection activity, improve performance)</li>
              <li>Small goodies, like feeding the EntityWorld with whole Entities(maybe loading from external resources), enabling/disabling systems and entities, getting Entity tag, API shortcuts(see unit tests for more on this), etc.</li>
         </ul>
    </section>
    <section>
        <h3>Getting Started</h3>
        <ul>
            <li>Entities are only an aggregation of Components, identified by a unique id</li> 
            <li>Components are only data</li>
            <li>Systems publish/subscribe to Components, creating behavior</li>
        </ul>
        There is much more to tell about this paradigm and we already have rich articles which inspired this framework. Some of them:
        <ul>
            <li><a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/">Entity Systems are the future of MMOG development</a></li>
            <li><a href="http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/">Evolve your Hierarchy</a></li>
            <li><a href="http://scottbilas.com/games/dungeon-siege">Scott Bilas post-mortem on Dungeon Siege development</a></li>
            <li><a href="http://gamesfromwithin.com/data-oriented-design">Data-Oriented Design</a></li>
        </ul>
        And many more can be found <a href="http://www.ploobs.com.br/forum/viewtopic.php?f=39&t=136">here.</a><br/><br/>
        Your components must inherit from the class Component. Example:
        <div class="highlight">
        <pre lang="csharp"><code>class Velocity : Component
{
        private float velocity;
        private float angle;

        public Velocity() { }

        public Velocity(float vector)
        {
            velocity = vector;
        }

        public Velocity(float velocity, float angle)
        {
            this.velocity = velocity;
            this.angle = angle;
        }

        public float Speed {
            get { return velocity;}
            set { velocity = value; }
        }

        public float Angle
        {
            get { return angle; }   
            set { angle = value;}
        }

        public void AddAngle(float a)
        {
            angle = (angle + a) % 360;
        }

        public float AngleAsRadians
        {
            get { return (float)Math.PI * angle / 180.0f; }
        }
}</code></pre>
        </div>
        A sample for entity assembling:
        <pre>Entity e = world.CreateEntity();
e.AddComponent(new Transform(200,400));
e.AddComponent(new Velocity(2.4f,0.9f));
e.Refresh();// always call Refresh() when adding/removing components!<code>
        </code></pre>
        Your systems should inherit from one of the following templates:
        <ul>
            <li>EntitySystem - the simplest system template, not tied to components, good for stuff like collision</li>
            <li>EntityProcessingSystem - a template for processing many entities, tied to components</li>
            <li>IntervalEntitySystem - a simple system template, not tied to components, process periodically, based on world delta.</li>
            <li>IntervalEntityProcessingSystem - a template that process entities periodically, based on world delta, tied to components.</li>
            <li>ParallelEntityProcessingSystem - a template to leverage your multicore CPU for processing many entities, tied to components</li>
            <li>QueueProcessingSystem</li>
            <li>HybridQueueProcessingSystem</li>
            <li>QueueProcessingSystemThreadSafe</li>
            <li>TagSystem - a simple system template, not tied to components, process a tagged entity</li>
            <li>IntervalTagSystem - a simple system template, not tied to components, process a tagged entity periodically, based on world delta.</li>
            <li>DelayedEntitySystem - a simple system template that starts process after a given time, based on world delta.</li>
            <li>DelayedEntityProcessingSystem - a template that starts processing entities after a given time, based on world delta. Tied to components</li>
        </ul>
        And here is a system example, using Velocity and Transform components to create the Movement behavior:
        <pre><code>public class MovementSystem : EntityProcessingSystem {
    ComponentMapper<Velocity> velocityMapper;
    ComponentMapper<Transform> transformMapper;

    public MovementSystem() : base(Aspect.All(typeof(Transform), typeof(Velocity))) { }

    public override void Initialize() {
        velocityMapper = new ComponentMapper<Velocity>(world);
        transformMapper = new ComponentMapper<Transform>(world);
    }

    public override void Process(Entity e) {
        Velocity velocity = velocityMapper.Get(e);
        float v = velocity.Speed;

        Transform transform = transformMapper.Get(e);

        float r = velocity.AngleAsRadians;

        float xn = transform.X + (TrigLUT.Cos(r) * v * world.Delta);
        float yn = transform.Y + (TrigLUT.Sin(r) * v * world.Delta);

        transform.SetLocation(xn, yn);
    }
}</code></pre>
        On your game initialization, create a new EntityWorld:
        <pre><code>var world = new EntityWorld();</code></pre>
        Add your systems to SystemManager:
        <pre><code>var systemManager = world.SystemManager;
systemManager.SetSystem(new MovementSystem(),ExecutionType.Update);
systemManager.SetSystem(new CollisionSystem(),ExecutionType.Update);
systemManager.SetSystem(new EnemySpawnSystem(),ExecutionType.Update);
systemManager.SetSystem(new RenderSystem(),ExecutionType.Draw);
systemManager.InitializeAll();
        </code></pre>
        On your game update loop, set the world delta and execute the systems:
        <pre><code>world.LoopStart();                
world.Delta = gameDelta;
systemManager.UpdateSynchronous(ExecutionType.Update);
        </code></pre>
        Execute your rendering systems on the draw loop:
        <pre><code>world.SystemManager.UpdateSynchronous(ExecutionType.Draw);</code></pre>
        And you are good to go. The Entity object has some intuitive methods like Delete(), GetComponent(), RemoveComponent(), which
        you can see in action on the <a href="https://github.com/thelinuxlich/starwarrior_CSharp">example game.</a>
    </section>
	<section>
		<h3>Aspects</h3>
		Aspects are used in the constructor of your entity systems to tell them which components they should be interested. At the moment we have three 
		methods to build Aspects:
		<ul>
			<li>Aspect.All(params Type[] types) - Most of the time you will use this option, so the system processes entities which have all components of the Aspect.</li>
			<li>Aspect.One(params Type[] types) - The system will process entities which have at least one of the components of the Aspect.</li>
			<li>Aspect.Exclude(params Type[] types) - The system will not process entities which have at least one of the components of the Aspect.</li>
		</ul>
		You can also compose your Aspect utilizing these methods together, example: 
		<pre><code>public LogEnemySystem() : base(Aspect.All(typeof(Health)).One(typeof(Koopa),typeof(Goomba),typeof(Magikoopa)).exclude(typeof(Ghost))) {}</code></pre>
	</section>
	<section>
		<h3>Templates</h3>
		Create your entity templates to avoid manually creating and configuring entities:
		<pre><code>public EnemyTemplate : Artemis.IEntityTemplate {
	public Entity BuildEntity(Entity e) {
		e.AddComponent(new Transform(200,400));
		e.AddComponent(new Velocity(2.4f,0.9f));
	}
}</code></pre>
		Then on your game initialization:
		<pre><code>world.SetEntityTemplate("Enemy", new EnemyTemplate());</code></pre>
		Create your entities with the template applied:
		<pre><code>var enemy = world.CreateEntity("Enemy");
enemy.Refresh();</code></pre>
	</section>
    <section>
        <h3>Documentation</h3>
        Coming soon.
    </section>
    <section>
        <h3>Discussion, issues, suggestions</h3>
        We have a forum section <a href="http://www.ploobs.com.br/forum/viewforum.php?f=39">here.</a>
    </section>
  </div>
  <footer>
      <p>Project maintained by <a href="https://github.com/thelinuxlich">thelinuxlich</a> and <a href="https://github.com/tpastor">tpastor</a></p>
  </footer>
  <!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
  </body>
</html>
